#include "StdAfx.h"
#include "timer.hpp"

CTimer::CTimer() {
	m_dblTimeScale = 1.0;
	m_nTimeInMilliseconds = 0;
	m_nPreviousTimeInMilliseconds = 0;
	m_nCyclesPerMillisecond = 0;
	memset(&m_ullOldPerfCounter, 0, sizeof(m_ullOldPerfCounter));
	m_bInitialized = false;
	m_dblPossibleFrametime = 0;
}

//must be called ALWAYS before Process ONLY ONCE
void CTimer::Initialise() {
	LARGE_INTEGER ullPerfFreq;
	if (QueryPerformanceFrequency(&ullPerfFreq)) {
		m_nCyclesPerMillisecond = (ullPerfFreq.QuadPart / 1000);

		if (ORIG_QueryPerformanceCounter)
			ORIG_QueryPerformanceCounter(&m_ullOldPerfCounter); //use the trampoline generated by minhook so we don't eat our modified values
		else
			QueryPerformanceCounter(&m_ullOldPerfCounter);

		m_bInitialized = true;
	} else {
		if (CCheat::GetCheat())
			CCheat::GetCheat()->m_pConsole->Printf("[SEVERE] CTimer::Initialise: QueryPerformanceFrequency failed\n");

		m_bInitialized = false;
	}
}

void CTimer::Process() {
	if (!m_bInitialized) return; //cycles per millis will be zero all the time so what's the point in updating stuff here

	m_nPreviousTimeInMilliseconds = m_nTimeInMilliseconds;
	if (m_nCyclesPerMillisecond != 0) {
		LARGE_INTEGER ullPerfCounter;

		if (ORIG_QueryPerformanceCounter)
			ORIG_QueryPerformanceCounter(&ullPerfCounter);
		else
			QueryPerformanceCounter(&ullPerfCounter);

		unsigned long long lluUpdInCycles = (ullPerfCounter.QuadPart - m_ullOldPerfCounter.QuadPart);
		m_ullOldPerfCounter = ullPerfCounter;
		double dblUpdInCyclesScaled = (double)lluUpdInCycles * m_dblTimeScale;
		m_dblPossibleFrametime = dblUpdInCyclesScaled / (double)m_nCyclesPerMillisecond; //scaled
		m_nTimeInMilliseconds = m_nTimeInMilliseconds + (unsigned long long) m_dblPossibleFrametime;
		//m_dblPossibleFrametime -= (unsigned long long) m_dblPossibleFrametime; //get rid of the exponent, only the mantissa part must stay
	}
}